// Navigation Manager - Gestion centralis√©e de la navigation
console.log('üß≠ Navigation Manager charg√©');

/**
 * Classe de gestion de la navigation
 */
class NavigationManager {
  constructor() {
    this.navLinks = [];
    this.sections = [];
    this.currentSection = null;
    this.isScrolling = false;
    this.mobileMenuOpen = false;
    this.scrollSpyActive = ConfigUtils.get('navigation.scrollSpy') !== false;
    this.smoothScrollEnabled = ConfigUtils.get('navigation.smoothScroll') !== false;
    this.scrollDuration = ConfigUtils.get('navigation.scrollDuration') || 800;
    this.scrollOffset = ConfigUtils.get('navigation.scrollOffset') || 70;
    this.mobileBreakpoint = ConfigUtils.get('navigation.mobileBreakpoint') || 768;
    
    // Variables pour la d√©tection de scroll am√©lior√©e
    this.lastScrollPosition = 0;
    this.scrollTimeout = null;
    this.isScrollingFast = false;
    this.lastScrollTime = 0;
    this.scrollCheckInterval = null;
    
    this.init();
  }

  /**
   * Initialise le gestionnaire de navigation
   */
  init() {
    // Attendre que le DOM soit charg√©
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', () => this.setupNavigation());
    } else {
      this.setupNavigation();
    }
  }

  /**
   * Configure la navigation
   */
  setupNavigation() {
    try {
      // R√©cup√©rer les √©l√©ments de navigation
      this.navLinks = Array.from(document.querySelectorAll(Selectors.nav.links));
      this.sections = Array.from(document.querySelectorAll('section[id]'));
      
      // Configurer les √©v√©nements
      this.setupEventListeners();
      
      // Initialiser le scroll spy
      if (this.scrollSpyActive) {
        this.setupScrollSpy();
        this.setupEnhancedScrollDetection();
      }
      
      // Mettre √† jour les liens actifs
      this.updateActiveLinks();
      
      console.log('‚úÖ Navigation Manager initialis√©');
      console.log(`üìå ${this.navLinks.length} liens de navigation trouv√©s`);
      console.log(`üìë ${this.sections.length} sections trouv√©es`);
      
    } catch (error) {
      console.error('‚ùå Erreur lors de l\'initialisation de la navigation:', error);
    }
  }

  /**
   * Configure les √©couteurs d'√©v√©nements
   */
  setupEventListeners() {
    // √âv√©nements de clic sur les liens de navigation
    this.navLinks.forEach(link => {
      link.addEventListener('click', (e) => this.handleNavLinkClick(e));
    });

    // √âv√©nement de d√©filement
    window.addEventListener('scroll', this.throttle(() => {
      if (this.scrollSpyActive) {
        this.updateActiveLinks();
      }
    }, 100));

    // √âv√©nement de redimensionnement
    window.addEventListener('resize', this.debounce(() => {
      this.updateActiveLinks();
    }, 250));

    // Toggle menu mobile
    const mobileToggle = document.querySelector(Selectors.nav.mobileToggle);
    if (mobileToggle) {
      mobileToggle.addEventListener('click', () => this.toggleMobileMenu());
    }

    // Fermer le menu mobile lors du clic sur un lien
    this.navLinks.forEach(link => {
      link.addEventListener('click', () => {
        if (this.mobileMenuOpen) {
          this.closeMobileMenu();
        }
      });
    });

    // Fermer le menu mobile lors du clic en dehors
    document.addEventListener('click', (e) => {
      const mobileMenu = document.querySelector(Selectors.nav.mobileMenu);
      const mobileToggle = document.querySelector(Selectors.nav.mobileToggle);
      
      if (this.mobileMenuOpen && mobileMenu && !mobileMenu.contains(e.target) && !mobileToggle.contains(e.target)) {
        this.closeMobileMenu();
      }
    });

    // Gestion des touches clavier
    document.addEventListener('keydown', (e) => {
      if (e.key === 'Escape' && this.mobileMenuOpen) {
        this.closeMobileMenu();
      }
    });
  }

  /**
   * G√®re le clic sur un lien de navigation
   * @param {Event} e - √âv√©nement de clic
   */
  handleNavLinkClick(e) {
    e.preventDefault();
    
    const link = e.currentTarget;
    const href = link.getAttribute('href');
    
    if (!href || href === '#') return;
    
    const targetId = href.startsWith('#') ? href.substring(1) : href;
    const targetSection = document.getElementById(targetId);
    
    if (!targetSection) {
      console.warn(`‚ö†Ô∏è Section non trouv√©e: ${targetId}`);
      return;
    }
    
    // √âmettre un √©v√©nement
    this.dispatchEvent('linkClick', { link, targetId, targetSection });
    
    // D√©filer vers la section
    this.scrollToSection(targetSection);
    
    // Jouer un son de clic si l'audio est activ√©
    if (window.playClickSound) {
      window.playClickSound();
    }
  }

  /**
   * D√©file vers une section sp√©cifique
   * @param {HTMLElement} section - Section cible
   * @param {number} duration - Dur√©e du d√©filement (ms)
   */
  scrollToSection(section, duration = this.scrollDuration) {
    if (!section || this.isScrolling) return;
    
    this.isScrolling = true;
    
    const targetPosition = section.offsetTop - this.scrollOffset;
    const startPosition = window.pageYOffset;
    const distance = targetPosition - startPosition;
    
    if (this.smoothScrollEnabled && duration > 0) {
      // D√©filement fluide
      const startTime = performance.now();
      
      const animateScroll = (currentTime) => {
        const elapsedTime = currentTime - startTime;
        const progress = Math.min(elapsedTime / duration, 1);
        
        // Fonction d'acc√©l√©ration (ease-in-out)
        const easeInOut = progress < 0.5 
          ? 2 * progress * progress 
          : 1 - Math.pow(-2 * progress + 2, 2) / 2;
        
        window.scrollTo(0, startPosition + distance * easeInOut);
        
        if (progress < 1) {
          requestAnimationFrame(animateScroll);
        } else {
          this.isScrolling = false;
          this.updateActiveLinks();
        }
      };
      
      requestAnimationFrame(animateScroll);
    } else {
      // D√©filement instantan√©
      window.scrollTo(0, targetPosition);
      this.isScrolling = false;
      this.updateActiveLinks();
    }
    
    // √âmettre un √©v√©nement
    this.dispatchEvent('scroll', { section, duration });
  }

  /**
   * Configure le scroll spy
   */
  setupScrollSpy() {
    // Cr√©er un Intersection Observer pour d√©tecter les sections visibles
    const observerOptions = {
      root: null,
      rootMargin: `-${this.scrollOffset}px 0px -${window.innerHeight - this.scrollOffset - 150}px 0px`,
      threshold: [0.44]
    };
    
    const observer = new IntersectionObserver((entries) => {
      let bestSection = null;
      let maxVisibility = 0;
      
      entries.forEach(entry => {
        if (entry.isIntersecting) {
          const visibilityRatio = entry.intersectionRatio;
          const rect = entry.boundingClientRect;
          const viewportHeight = window.innerHeight;
          const centerDistance = Math.abs(rect.top + rect.height/2 - viewportHeight/2);
          const score = visibilityRatio * 2000 - centerDistance;
          
          if (score > maxVisibility) {
            maxVisibility = score;
            bestSection = entry.target;
          }
        }
      });
      
      if (bestSection && bestSection !== this.currentSection) {
        this.currentSection = bestSection;
        this.updateActiveLinks();
      }
    }, observerOptions);
    
    // Observer toutes les sections
    this.sections.forEach(section => {
      observer.observe(section);
    });
  }

  /**
   * Configure un syst√®me de d√©tection de scroll am√©lior√©
   */
  setupEnhancedScrollDetection() {
    // √âcouteur de scroll avec d√©tection de vitesse
    window.addEventListener('scroll', () => {
      const currentTime = Date.now();
      const currentScrollPosition = window.pageYOffset;
      const scrollDelta = Math.abs(currentScrollPosition - this.lastScrollPosition);
      const timeDelta = currentTime - this.lastScrollTime;
      
      // D√©tecter si le scroll est rapide
      this.isScrollingFast = timeDelta > 0 && scrollDelta / timeDelta > 2;
      
      this.lastScrollPosition = currentScrollPosition;
      this.lastScrollTime = currentTime;
      
      // Annuler le timeout pr√©c√©dent
      if (this.scrollTimeout) {
        clearTimeout(this.scrollTimeout);
      }
      
      // Si le scroll est rapide, v√©rifier plus fr√©quemment
      if (this.isScrollingFast) {
        this.forceUpdateActiveSection();
        this.scrollTimeout = setTimeout(() => {
          this.forceUpdateActiveSection();
        }, 50);
      } else {
        // Scroll normal - v√©rifier apr√®s un court d√©lai
        this.scrollTimeout = setTimeout(() => {
          this.forceUpdateActiveSection();
        }, 100);
      }
    }, { passive: true });
    
    // V√©rification p√©riodique pendant le scroll rapide
    this.startScrollCheckInterval();
  }

  /**
   * D√©marre un intervalle de v√©rification pendant le scroll
   */
  startScrollCheckInterval() {
    if (this.scrollCheckInterval) {
      clearInterval(this.scrollCheckInterval);
    }
    
    this.scrollCheckInterval = setInterval(() => {
      if (this.isScrollingFast) {
        this.forceUpdateActiveSection();
      }
    }, 150);
    
    // Arr√™ter l'intervalle apr√®s 2 secondes d'inactivit√©
    setTimeout(() => {
      if (this.scrollCheckInterval) {
        clearInterval(this.scrollCheckInterval);
        this.scrollCheckInterval = null;
      }
    }, 2000);
  }

  /**
   * Force la mise √† jour de la section active
   */
  forceUpdateActiveSection() {
    if (this.isScrolling) return;
    
    const scrollPosition = window.pageYOffset + this.scrollOffset + 30;
    const viewportHeight = window.innerHeight;
    
    const bestSection = this.sections.reduce((best, section) => {
      const sectionTop = section.offsetTop;
      const sectionBottom = sectionTop + section.offsetHeight;
      const sectionHeight = section.offsetHeight;
      
      if (scrollPosition >= sectionTop - 100 && scrollPosition < sectionBottom + 100) {
        const centerDistance = Math.abs((sectionTop + sectionHeight/2) - (scrollPosition + viewportHeight/2));
        const visibilityScore = 2000 - centerDistance;
        
        if (!best || visibilityScore > best.score) {
          return { section, score: visibilityScore };
        }
      }
      return best;
    }, null)?.section;
    
    if (bestSection && bestSection !== this.currentSection) {
      this.currentSection = bestSection;
      this.updateActiveLinks();
    }
  }

  /**
   * Met √† jour les liens de navigation actifs
   */
  updateActiveLinks() {
    if (this.isScrolling) return;
    
    let activeSection = this.currentSection;
    
    // Si aucune section n'est d√©finie, la d√©terminer par la position de d√©filement
    if (!activeSection) {
      const scrollPosition = window.pageYOffset + this.scrollOffset + 50;
      const viewportHeight = window.innerHeight;
      
      activeSection = this.sections.reduce((best, section) => {
        const sectionTop = section.offsetTop;
        const sectionBottom = sectionTop + section.offsetHeight;
        const sectionHeight = section.offsetHeight;
        
        if (scrollPosition >= sectionTop && scrollPosition < sectionBottom) {
          const centerDistance = Math.abs((sectionTop + sectionHeight/2) - (scrollPosition + viewportHeight/2));
          const visibilityScore = 1000 - centerDistance;
          
          if (!best || visibilityScore > best.score) {
            return { section, score: visibilityScore };
          }
        }
        return best;
      }, null)?.section;
    }
    
    // Mettre √† jour les classes actives
    this.navLinks.forEach(link => {
      const href = link.getAttribute('href');
      if (!href || href === '#') return;
      
      const targetId = href.startsWith('#') ? href.substring(1) : href;
      
      if (activeSection && activeSection.id === targetId) {
        link.classList.add(Classes.navigation.active);
      } else {
        link.classList.remove(Classes.navigation.active);
      }
    });
  }

  /**
   * Ouvre le menu mobile
   */
  openMobileMenu() {
    const mobileMenu = document.querySelector(Selectors.nav.mobileMenu);
    const mobileToggle = document.querySelector(Selectors.nav.mobileToggle);
    
    if (mobileMenu) {
      mobileMenu.classList.add(Classes.navigation.mobileOpen);
      this.mobileMenuOpen = true;
      
      // Bloquer le d√©filement du body
      document.body.style.overflow = 'hidden';
      
      // √âmettre un √©v√©nement
      this.dispatchEvent('mobileToggle', { open: true });
      
      console.log('üì± Menu mobile ouvert');
    }
  }

  /**
   * Ferme le menu mobile
   */
  closeMobileMenu() {
    const mobileMenu = document.querySelector(Selectors.nav.mobileMenu);
    const mobileToggle = document.querySelector(Selectors.nav.mobileToggle);
    
    if (mobileMenu) {
      mobileMenu.classList.remove(Classes.navigation.mobileOpen);
      this.mobileMenuOpen = false;
      
      // R√©activer le d√©filement du body
      document.body.style.overflow = '';
      
      // √âmettre un √©v√©nement
      this.dispatchEvent('mobileToggle', { open: false });
      
      console.log('üì± Menu mobile ferm√©');
    }
  }

  /**
   * Bascule le menu mobile
   */
  toggleMobileMenu() {
    if (this.mobileMenuOpen) {
      this.closeMobileMenu();
    } else {
      this.openMobileMenu();
    }
  }

  /**
   * V√©rifie si le menu mobile est ouvert
   * @returns {boolean}
   */
  isMobileMenuOpen() {
    return this.mobileMenuOpen;
  }

  /**
   * V√©rifie si l'affichage est mobile
   * @returns {boolean}
   */
  isMobile() {
    return window.innerWidth <= this.mobileBreakpoint;
  }

  /**
   * Obtient la section actuellement active
   * @returns {HTMLElement|null}
   */
  getActiveSection() {
    return this.currentSection;
  }

  /**
   * Obtient le lien de navigation actif
   * @returns {HTMLElement|null}
   */
  getActiveLink() {
    return this.navLinks.find(link => link.classList.contains(Classes.navigation.active)) || null;
  }

  /**
   * D√©file vers le haut de la page
   * @param {number} duration - Dur√©e du d√©filement
   */
  scrollToTop(duration = this.scrollDuration) {
    this.scrollToSection(document.body, duration);
  }

  /**
   * D√©file vers le bas de la page
   * @param {number} duration - Dur√©e du d√©filement
   */
  scrollToBottom(duration = this.scrollDuration) {
    const bottomSection = this.sections[this.sections.length - 1];
    if (bottomSection) {
      this.scrollToSection(bottomSection, duration);
    }
  }

  /**
   * D√©file vers une section par son ID
   * @param {string} sectionId - ID de la section
   * @param {number} duration - Dur√©e du d√©filement
   */
  scrollToSectionById(sectionId, duration = this.scrollDuration) {
    const section = document.getElementById(sectionId);
    if (section) {
      this.scrollToSection(section, duration);
    } else {
      console.warn(`‚ö†Ô∏è Section non trouv√©e: ${sectionId}`);
    }
  }

  /**
   * Active ou d√©sactive le scroll spy
   * @param {boolean} active - √âtat du scroll spy
   */
  setScrollSpyActive(active) {
    this.scrollSpyActive = active;
    console.log(`üîç Scroll spy ${active ? 'activ√©' : 'd√©sactiv√©'}`);
  }

  /**
   * Active ou d√©sactive le d√©filement fluide
   * @param {boolean} enabled - √âtat du d√©filement fluide
   */
  setSmoothScrollEnabled(enabled) {
    this.smoothScrollEnabled = enabled;
    console.log(`üåä D√©filement fluide ${enabled ? 'activ√©' : 'd√©sactiv√©'}`);
  }

  /**
   * D√©finit la dur√©e du d√©filement
   * @param {number} duration - Dur√©e en millisecondes
   */
  setScrollDuration(duration) {
    this.scrollDuration = Math.max(0, duration);
    console.log(`‚è±Ô∏è Dur√©e de d√©filement d√©finie √† ${this.scrollDuration}ms`);
  }

  /**
   * D√©finit l'offset de d√©filement
   * @param {number} offset - Offset en pixels
   */
  setScrollOffset(offset) {
    this.scrollOffset = Math.max(0, offset);
    console.log(`üìè Offset de d√©filement d√©fini √† ${this.scrollOffset}px`);
  }

  /**
   * √âmet un √©v√©nement de navigation
   * @param {string} type - Type d'√©v√©nement
   * @param {Object} data - Donn√©es de l'√©v√©nement
   */
  dispatchEvent(type, data = {}) {
    const event = new CustomEvent(Events.navigation[type], {
      detail: { ...data, timestamp: Date.now() }
    });
    document.dispatchEvent(event);
  }

  /**
   * Fonction de debounce
   * @param {Function} func - Fonction √† d√©bouncer
   * @param {number} wait - Temps d'attente
   * @returns {Function}
   */
  debounce(func, wait) {
    let timeout;
    return function executedFunction(...args) {
      const later = () => {
        clearTimeout(timeout);
        func(...args);
      };
      clearTimeout(timeout);
      timeout = setTimeout(later, wait);
    };
  }

  /**
   * Fonction de throttle
   * @param {Function} func - Fonction √† throttliser
   * @param {number} limit - Limite de temps
   * @returns {Function}
   */
  throttle(func, limit) {
    let inThrottle;
    return function() {
      const args = arguments;
      const context = this;
      if (!inThrottle) {
        func.apply(context, args);
        inThrottle = true;
        setTimeout(() => inThrottle = false, limit);
      }
    };
  }

  /**
   * Obtient l'√©tat actuel de la navigation
   * @returns {Object}
   */
  getStatus() {
    return {
      navLinksCount: this.navLinks.length,
      sectionsCount: this.sections.length,
      currentSection: this.currentSection?.id || null,
      isScrolling: this.isScrolling,
      mobileMenuOpen: this.mobileMenuOpen,
      scrollSpyActive: this.scrollSpyActive,
      smoothScrollEnabled: this.smoothScrollEnabled,
      scrollDuration: this.scrollDuration,
      scrollOffset: this.scrollOffset,
      isMobile: this.isMobile()
    };
  }
}

// Cr√©er une instance globale
let navigationManager;

// Initialiser le gestionnaire de navigation quand le DOM est pr√™t
document.addEventListener('DOMContentLoaded', () => {
  navigationManager = new NavigationManager();
  window.navigationManager = navigationManager;
});

// Exporter les fonctions globales pour la compatibilit√©
window.scrollToSection = (sectionId, duration) => navigationManager?.scrollToSectionById(sectionId, duration);
window.scrollToTop = (duration) => navigationManager?.scrollToTop(duration);
window.scrollToBottom = (duration) => navigationManager?.scrollToBottom(duration);
window.openMobileMenu = () => navigationManager?.openMobileMenu();
window.closeMobileMenu = () => navigationManager?.closeMobileMenu();
window.toggleMobileMenu = () => navigationManager?.toggleMobileMenu();
window.getNavigationStatus = () => navigationManager?.getStatus();

console.log('üß≠ Navigation Manager pr√™t √† √™tre initialis√©');
